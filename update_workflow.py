# update_workflow.py
import yaml
import json
import os
from urllib.parse import urlparse

# Custom Dumper to handle multi-line strings correctly
class LiteralString(str):
    pass

def literal_presenter(dumper, data):
    return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='|')

yaml.add_representer(LiteralString, literal_presenter)


BADGE_CONFIG_PATH = 'badges.yml'
WORKFLOW_PATH = '.github/workflows/generate-badge.yml'
ISSUER_OUTPUT_DIR = 'public'

def update_workflow_file(config):
    """Dynamically builds and completely overwrites the generate-badge.yml workflow."""
    print("\n--- Updating Generation Workflow ---")
    
    badge_ids = list(config.get('badges', {}).keys())
    global_inputs = config.get('global_inputs', {})
    
    # --- Determine which UI inputs are needed ---
    ui_inputs = set()
    for badge_data in config.get('badges', {}).values():
        for input_key, input_config in badge_data.get('inputs', {}).items():
            if not (isinstance(input_config, dict) and input_config.get('input') is False):
                ui_inputs.add(input_key)
    if any(badge.get('expires') for badge in config.get('badges', {}).values()):
        ui_inputs.add('expires')
    print(f"All unique UI inputs required: {sorted(list(ui_inputs))}")

    # --- NEW: Collect only the secrets that are actually needed ---
    required_secrets = {'RECIPIENT_SALT'} # Always required
    for issuer_data in config.get('issuers', {}).values():
        secret_name = issuer_data.get('private_key_secret_name')
        if secret_name:
            required_secrets.add(secret_name)
    print(f"All unique secrets required: {sorted(list(required_secrets))}")

    # --- Build the dynamic env block with only the required secrets ---
    dynamic_env = {secret: f'${{{{ secrets.{secret} }}}}' for secret in sorted(list(required_secrets))}

    # --- Build the complete workflow dictionary ---
    run_script = LiteralString(
        'mkdir -p badges_output\n'
        'python_args="--output-dir badges_output"\n'
        'for key in $(echo \'${{ toJSON(github.event.inputs) }}\' | jq -r \'keys[]\'); do\n'
        '  value=$(echo \'${{ toJSON(github.event.inputs) }}\' | jq -r --arg k "$key" \'.[$k]\')\n'
        '  if [[ "$value" != "null" && -n "$value" ]]; then\n'
        '    python_args="$python_args --$key \\"$value\\""\n'
        '  fi\n'
        'done\n'
        'eval "python generate_badge.py $python_args"\n'
    )
    
    new_workflow_data = {
        'name': 'Generate Open Badge',
        'on': {'workflow_dispatch': {'inputs': {}}},
        'jobs': {
            'generate-badge': {
                'runs-on': 'ubuntu-latest',
                'permissions': {'contents': 'read'},
                'steps': [
                    {'name': 'Checkout repository', 'uses': 'actions/checkout@v4'},
                    {'name': 'Set up Python 3.10', 'uses': 'actions/setup-python@v5', 'with': {'python-version': '3.10'}},
                    {'name': 'Install dependencies', 'run': 'pip install -r requirements.txt'},
                    {'name': 'Generate Badge', 'run': run_script, 'env': dynamic_env},
                    {
                        'name': 'Upload Badge as Artifact',
                        'uses': 'actions/upload-artifact@v4',
                        'with': {
                            'name': 'open-badge-${{ github.event.inputs.badge_id }}-${{ github.run_id }}',
                            'path': 'badges_output/*.png'
                        }
                    }
                ]
            }
        }
    }
    
    dynamic_inputs = {
        'badge_id': {'description': 'Select the badge', 'required': True, 'type': 'choice', 'options': sorted(badge_ids)},
        'recipient_email': {'description': "Recipient's Email", 'required': True, 'type': 'string'}
    }
    
    for input_key in sorted(list(ui_inputs)):
        input_config = global_inputs.get(input_key, {})
        if input_key == 'expires':
            input_config = {'description': 'Badge expiration - YYYY-MM-DDTHH:MM:SSZ format (optional)'}

        dynamic_inputs[input_key] = {
            'description': input_config.get('description', f'Value for {input_key}'),
            'required': False, 'type': 'string', 'default': input_config.get('default', '')
        }
    
    new_workflow_data['on']['workflow_dispatch']['inputs'] = dynamic_inputs
    
    warning_comment = "# WARNING: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT MANUALLY.\n"

    print("Rebuilding generate-badge.yml...")
    with open(WORKFLOW_PATH, 'w') as f:
        f.write(warning_comment)
        yaml.dump(new_workflow_data, f, sort_keys=False, width=120)
        
    print(f"Successfully created/updated {WORKFLOW_PATH}.")


def generate_issuer_files(config):
    """Generates public issuer JSON files from the issuers block."""
    print("\n--- Generating Issuer Files ---")
    os.makedirs(ISSUER_OUTPUT_DIR, exist_ok=True)
    repo_url = config['repository_url']
    
    for issuer_id, issuer_data in config.get('issuers', {}).items():
        filename = f"{issuer_id}-issuer.json"
        output_path = os.path.join(ISSUER_OUTPUT_DIR, filename)
        issuer_profile = json.loads(json.dumps(issuer_data))
        issuer_profile['id'] = f"{repo_url}/{ISSUER_OUTPUT_DIR}/{filename}"
        
        for key, value in issuer_profile.items():
            if isinstance(value, str):
                issuer_profile[key] = value.format(repository_url=repo_url)
        
        issuer_profile.update({'@context': "https://wid.org/openbadges/v2", 'type': "Issuer"})
        issuer_profile.pop('private_key_secret_name', None)

        with open(output_path, 'w') as f:
            json.dump(issuer_profile, f, indent=2)
        print(f"Generated/Updated issuer file: {output_path}")

def generate_badge_class_files(config):
    """Generates public BadgeClass JSON files from the badges block."""
    print("\n--- Generating BadgeClass Files ---")
    BADGE_CLASS_OUTPUT_DIR = os.path.join(ISSUER_OUTPUT_DIR, 'badges')
    os.makedirs(BADGE_CLASS_OUTPUT_DIR, exist_ok=True)
    repo_url = config['repository_url']

    for badge_id, badge_data in config.get('badges', {}).items():
        filename = f"{badge_id}.json"
        output_path = os.path.join(BADGE_CLASS_OUTPUT_DIR, filename)

        # Get the full issuer object
        issuer_id = badge_data['issuer_id']
        issuer_data = config['issuers'][issuer_id]
        full_issuer_object = json.loads(json.dumps(issuer_data))
        issuer_filename = f"{issuer_id}-issuer.json"
        full_issuer_object['id'] = f"{repo_url}/{ISSUER_OUTPUT_DIR}/{issuer_filename}"
        for key, value in full_issuer_object.items():
            if isinstance(value, str):
                full_issuer_object[key] = value.format(repository_url=repo_url)
        full_issuer_object.pop('private_key_secret_name', None)

        # Create the BadgeClass object
        badge_class_obj = {
            '@context': "https://w3id.org/openbadges/v2",
            'type': 'BadgeClass',
            'id': f"{repo_url}/{BADGE_CLASS_OUTPUT_DIR}/{filename}",
            'name': badge_data['name'],
            'description': badge_data['description'],
            'image': badge_data['image'].format(repository_url=repo_url),
            'criteria': {'narrative': badge_data['criteria']},
            'issuer': full_issuer_object
        }

        with open(output_path, 'w') as f:
            json.dump(badge_class_obj, f, indent=2)
        print(f"Generated/Updated BadgeClass file: {output_path}")

if __name__ == "__main__":
    print("--- Starting update process ---")
    with open(BADGE_CONFIG_PATH, 'r') as f:
        config = yaml.safe_load(f)
    
    update_workflow_file(config)
    generate_issuer_files(config)
    generate_badge_class_files(config)
    print("\n--- Update process finished ---")
