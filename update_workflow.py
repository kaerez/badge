# update_workflow.py
import yaml
import json
import os
from urllib.parse import urlparse

# Custom Dumper to handle multi-line strings correctly
class LiteralString(str):
    pass

def literal_presenter(dumper, data):
    return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='|')

yaml.add_representer(LiteralString, literal_presenter)


BADGE_CONFIG_PATH = 'badges.yml'
WORKFLOW_PATH = '.github/workflows/generate-badge.yml'
ISSUER_OUTPUT_DIR = 'public'

def update_workflow_file(config):
    """Dynamically builds and completely overwrites the generate-badge.yml workflow."""
    print("\n--- Updating Generation Workflow ---")
    
    badge_ids = list(config.get('badges', {}).keys())
    global_inputs = config.get('global_inputs', {})
    
    # --- Determine which UI inputs are needed ---
    ui_inputs = set()
    for badge_data in config.get('badges', {}).values():
        for input_key, input_config in badge_data.get('inputs', {}).items():
            if not (isinstance(input_config, dict) and input_config.get('input') is False):
                ui_inputs.add(input_key)
    if any(badge.get('expires') for badge in config.get('badges', {}).values()):
        ui_inputs.add('expires')
    print(f"All unique UI inputs required: {sorted(list(ui_inputs))}")

    # --- NEW: Collect only the secrets that are actually needed ---
    required_secrets = {'RECIPIENT_SALT'} # Always required
    for issuer_data in config.get('issuers', {}).values():
        secret_name = issuer_data.get('private_key_secret_name')
        if secret_name:
            required_secrets.add(secret_name)
    print(f"All unique secrets required: {sorted(list(required_secrets))}")

    # --- Build the dynamic env block with only the required secrets ---
    dynamic_env = {secret: f'${{{{ secrets.{secret} }}}}' for secret in sorted(list(required_secrets))}

    # --- Build the complete workflow dictionary ---
    run_script = LiteralString(
        'mkdir -p badges_output\n'
        'python_args="--output-dir badges_output"\n'
        'for key in $(echo \'${{ toJSON(github.event.inputs) }}\' | jq -r \'keys[]\'); do\n'
        '  value=$(echo \'${{ toJSON(github.event.inputs) }}\' | jq -r --arg k "$key" \'.[$k]\')\n'
        '  if [[ "$value" != "null" && -n "$value" ]]; then\n'
        '    python_args="$python_args --$key \\"$value\\""\n'
        '  fi\n'
        'done\n'
        'eval "python generate_badge.py $python_args"\n'
    )
    
    new_workflow_data = {
        'name': 'Generate Open Badge',
        'on': {'workflow_dispatch': {'inputs': {}}},
        'jobs': {
            'generate-badge': {
                'runs-on': 'ubuntu-latest',
                'permissions': {'contents': 'read'},
                'steps': [
                    {'name': 'Checkout repository', 'uses': 'actions/checkout@v4'},
                    {'name': 'Set up Python 3.10', 'uses': 'actions/setup-python@v5', 'with': {'python-version': '3.10'}},
                    {'name': 'Install dependencies', 'run': 'pip install -r requirements.txt'},
                    {'name': 'Generate Badge', 'run': run_script, 'env': dynamic_env},
                    {
                        'name': 'Upload Badge as Artifact',
                        'uses': 'actions/upload-artifact@v4',
                        'with': {
                            'name': 'open-badge-${{ github.event.inputs.badge_id }}-${{ github.run_id }}',
                            'path': 'badges_output/*.png'
                        }
                    }
                ]
            }
        }
    }
    
    dynamic_inputs = {
        'badge_id': {'description': 'Select the badge', 'required': True, 'type': 'choice', 'options': sorted(badge_ids)},
        'recipient_email': {'description': "Recipient's Email", 'required': True, 'type': 'string'}
    }
    
    for input_key in sorted(list(ui_inputs)):
        input_config = global_inputs.get(input_key, {})
        if input_key == 'expires':
            input_config = {'description': 'Badge expiration - YYYY-MM-DDTHH:MM:SSZ format (optional)'}

        dynamic_inputs[input_key] = {
            'description': input_config.get('description', f'Value for {input_key}'),
            'required': False, 'type': 'string', 'default': input_config.get('default', '')
        }
    
    new_workflow_data['on']['workflow_dispatch']['inputs'] = dynamic_inputs
    
    warning_comment = "# WARNING: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT MANUALLY.\n"

    print("Rebuilding generate-badge.yml...")
    with open(WORKFLOW_PATH, 'w') as f:
        f.write(warning_comment)
        yaml.dump(new_workflow_data, f, sort_keys=False, width=120)
        
    print(f"Successfully created/updated {WORKFLOW_PATH}.")


from jwcrypto import jwk

def pem_to_jwk(pem_file_path):
    """Reads a PEM file and converts it to a public JWK."""
    with open(pem_file_path, 'rb') as pem_file:
        public_key = jwk.JWK.from_pem(pem_file.read())
    # Return public part as a dictionary
    return json.loads(public_key.export_public())

def generate_issuer_files(config):
    """Generates public issuer JSON files from the issuers block."""
    print("\n--- Generating Issuer Files ---")
    os.makedirs(ISSUER_OUTPUT_DIR, exist_ok=True)
    repo_url = config['repository_url']
    
    for issuer_id, issuer_data in config.get('issuers', {}).items():
        filename = f"{issuer_id}-issuer.json"
        output_path = os.path.join(ISSUER_OUTPUT_DIR, filename)

        # Create the base profile by copying data
        issuer_profile = json.loads(json.dumps(issuer_data))

        # Remove fields that are not part of the OBv3 issuer profile
        issuer_profile.pop('private_key_secret_name', None)
        public_key_path_str = issuer_profile.pop('publicKey', None)

        # Set required OBv3 fields
        issuer_profile['@context'] = ["https://www.w3.org/ns/credentials/v2", "https://purl.imsglobal.org/spec/ob/v3p0/context-3.0.0.json"]
        issuer_profile['type'] = ["Issuer", "Profile"]
        issuer_profile['id'] = f"{repo_url}/{ISSUER_OUTPUT_DIR}/{filename}"
        
        # Process URL formatting
        for key, value in issuer_profile.items():
            if isinstance(value, str):
                issuer_profile[key] = value.format(repository_url=repo_url)

        # Add verification method using the public key
        if public_key_path_str:
            public_key_path = public_key_path_str.format(repository_url=repo_url)
            # The public_key_path in the YAML is relative to the repo root, e.g. "public/ksec.pem"
            # We need to construct the full local path to read it.
            local_pem_path = public_key_path.replace(f"{repo_url}/", "")
            if os.path.exists(local_pem_path):
                public_jwk = pem_to_jwk(local_pem_path)
                issuer_profile['verification'] = {
                    "id": f"{issuer_profile['id']}#key-1",
                    "type": "CryptographicKey",
                    "controller": issuer_profile['id'],
                    "publicKeyJwk": public_jwk
                }
            else:
                print(f"Warning: PEM file not found at {local_pem_path} for issuer {issuer_id}")

        with open(output_path, 'w') as f:
            json.dump(issuer_profile, f, indent=2)
        print(f"Generated/Updated v3.0 issuer file: {output_path}")


def generate_badge_class_files(config):
    """Generates public BadgeClass JSON files from the badges block."""
    print("\n--- Generating BadgeClass Files ---")
    BADGE_CLASS_OUTPUT_DIR = os.path.join(ISSUER_OUTPUT_DIR, 'badges')
    os.makedirs(BADGE_CLASS_OUTPUT_DIR, exist_ok=True)
    repo_url = config['repository_url']

    for badge_id, badge_data in config.get('badges', {}).items():
        filename = f"{badge_id}.json"
        output_path = os.path.join(BADGE_CLASS_OUTPUT_DIR, filename)

        issuer_id = badge_data['issuer_id']
        issuer_url = f"{repo_url}/{ISSUER_OUTPUT_DIR}/{issuer_id}-issuer.json"

        # Create the BadgeClass object
        badge_class_obj = {
            '@context': ["https://www.w3.org/ns/credentials/v2", "https://purl.imsglobal.org/spec/ob/v3p0/context-3.0.0.json"],
            'type': 'BadgeClass',
            'id': f"{repo_url}/{BADGE_CLASS_OUTPUT_DIR}/{filename}",
            'issuer': issuer_url,
            'name': badge_data['name'],
            'description': badge_data['description'],
            'image': badge_data['image'].format(repository_url=repo_url),
            'criteria': {
                'id': f"{repo_url}/criteria/{badge_id}.html", # Assuming criteria might have its own page
                'type': 'Criteria',
                'narrative': badge_data['criteria']
            }
        }
        # Clean up unnecessary fields from badge_data if any were copied
        badge_class_obj.pop('issuer_id', None)
        badge_class_obj.pop('inputs', None)
        badge_class_obj.pop('expires', None)

        with open(output_path, 'w') as f:
            json.dump(badge_class_obj, f, indent=2)
        print(f"Generated/Updated v3.0 BadgeClass file: {output_path}")

if __name__ == "__main__":
    print("--- Starting update process ---")
    with open(BADGE_CONFIG_PATH, 'r') as f:
        config = yaml.safe_load(f)
    
    update_workflow_file(config)
    generate_issuer_files(config)
    generate_badge_class_files(config)
    print("\n--- Update process finished ---")
